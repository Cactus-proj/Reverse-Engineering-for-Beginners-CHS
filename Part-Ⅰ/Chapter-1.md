# Part I 代码片段

当作者第一次学C语言和之后学C++时，他经常写一小段代码，编译一下，然后观察输出的汇编语言，这种习惯让他很容易理解在他写的代码背后发生了什么。他经常这样做，以至于C/C++代码和编译器产生的汇编语言的关系已经深深地印在他的脑海里，这样他很容易就能想出C的代码和函数粗略的样子。或许这个技巧对其他初学者能有所帮助。

关于练习
-
在作者学习C语言时，他经常些写一些C语言的小函数，然后逐渐的将他们重写成汇编语言，并尝试让代码尽可能的短。现在这种做法不是很值得尝试，因为很难在效率上和现代编译器相竞争。这是一种深入理解汇编语言的好方法，因此，你可以放轻松一些，随便在这本书里找一段汇编代码然后尝试让他更短一些。当然不要忘记测试你所写的汇编代码。

优化等级和调试信息
-
源代码可以用不同的编译器,以不同的优化等级来编译。典型的编译器有三种优化等级，其中0级代表不优化。优化既可以针对代码的体积，也可以针对运行速度。一个无优化的编译器编译会更快一点，生成的代码也更容易理解一些(虽然很冗长)。反之一个带优化的编译器会运行的更慢，并尝试编译出运行的更快的代码(但代码并不会更紧凑)。除了优化的级别和方向外，一个编译器还可能在输出文件里包含一些调试信息，这样产生的代码更容易调试。还有一个关于编译器的重要特性，那就是在输出里面，可能会有源代码到机器码地址的连接。另一方面，待优化的编译器，更倾向于将所有的源代码优化掉后再输出，因此源代码不会出现在输出的机器码里。一个逆向工程师这两种情况都有可能遇到，仅仅因为有的开发者会打开优化，有的没有。所以，在这本书里如果可能，我们会关注每个例子的调试和释放版本的代码特征。

___


# 第一章
# CPU简介

CPU就是执行组成程序的机器码的工作单元。

**词汇表：**

**Instruction**：CPU的原指令，简单的例子：将数据寄存器之间进行转移操作，对数据进行操作，算术操作。原则上每种CPU会有自己独特的一套指令构架(Instruction Set Architecture(ISA))。

**Machine code**: 机器码，CPU能直接处理的代码。每条指令都会被译成几个字节的指令码。

**Assembly Language**: 汇编语言，助记码和其他一些例如宏那样的扩展组成的，便于程序员编写的语言。

**CPU register**：CPU寄存器，每个CPU都有一些通用寄存器(General Purpose Registers(GPR))。X86有8个，x86-64(amd64)有16个，ARM有16个，最简单去理解寄存器的方法就是，把寄存器想成一个未指定类型的临时变量。想象你在使用高级语言编程，并且只能用8个32bit(或 64-bit)的变量。但是只用这些可以完成非常多的事情。

那么机器码跟程序语言有什么区别呢？对于人类来讲，使用例如C/C++, Java, Python这样编程语言会比较简单，但是CPU更喜欢低级抽象的东西。真希望有一天CPU也能直接执行高级语言的语句，但那样CPU肯定会变得毕竟天的CPU复杂好几倍。人类之所以使用汇编语言会感觉不很方便，是因为它非常的低级，而且很难用它写非常长的代码而不出现错误。将高级语言转换到汇编语言的程序，被称为编译器。

## 1.1 关于不同指令集的一些话
